\documentclass[svgnames]{article}

\input{preamble.tex}

% Dokument
\begin{document}
\maketitle
\tableofcontents
\pagebreak

	\section{Introduction}
	
	In the world of today where technology is advancing faster than ever before this "Maturitätsarbeit" tries to shine a light into the corner of self-built and autonomous drones.
	
	However, it first needs to be defined what a drone even is. According to the Cambridge Dictionary, a drone is defined as: \textit{an aircraft that does not have a pilot but is controlled by someone on the ground} \cite{cambridgedrone}. In this work, the term 'drone' will refer to a quadcopter which is a drone with four motors and propellers and not a conventional \gls{UAV}, which is mostly used for military grade drones. 

	In current conflicts the meanings of \gls{UAV} and quadcopters have become more entangled than ever. The typical hobbyist drone is now widely and effectively used to target enemy forces. In the Ukraine war drones are one of the most effective weapons to use against the Russian aggressor for example they use drones with thermite canisters attached to them to target the enemies under tree covers \cite{thermitedrones}. Since the war began the drones have become increasingly autonomous. Drone pilots with more advanced setups, are able to simply lock onto the target and let the drone follow and detonate near it \cite{nytimesaidrones}. This increased use in war has also had an impact on the hobby side of the project. The most used \gls{ESC} firmware BLHeli\_32 ceased its operation due to laws being passed in Norway that penalised firms that are not able to verify that their products are not used in wars \cite{blhelidead}. Which is really difficult to do regarding that both sides in the Ukraine war are buying the \glspl{ESC} no matter what software is on them.  

	% TODO write personal motivation
	% TODO introduction
	% do at the end of the writing process
	% drones are being used in war more and more self-built ones(Blheli32 is dead, because of the use in wars.)
	% article about more and more autonomous drones in the Ukraine-Russia War
	
	% personal motivation

	\section{Personal Motivation}
	% TODO might delete and put into introduction
	\section{Literature Review}
	% TODO rather short
	\subsection{General Software Considerations}
	% TODO work around the same topic that already exists
	\subsubsection{Open Source Software}
	An important part of this "Maturitätsarbeit" is \gls{OSS}. \gls{OSS} is software which everybody can download and develop in their own time. This process is known as 'forking', which refers to when a person other than the original developer takes the code and modifies it independently. The main benefit over closed software is that it can be freely downloaded by everyone and everybody can modify it as they see fit. However the downside is that if the development team loses interest, the software will become outdated and will not work smoothly with other systems anymore. Both aspects will later be found both useful and time-consuming. 
	
	
	\subsubsection{Flight Softwares}
	Based on the literature reviewed there are three main softwares to consider when it comes to drones Betaflight, INAV and Ardupilot. All of them are open source. Multiwii is the origin of Betaflight and INAV. Multwii was Arduino based and then upgraded to Baseflight to be able to utilize a better chipset. Then it was forked to Cleanflight, which was later forked again into Betaflight and INAV \cite{history}. 
	
	The following overview of the three softwares, is mostly based on the article written by \textcite{firmwarearticle} and a video made by \textcite{firmwarevideo}.
	
	Betaflight appears to be the go-to option for \gls{FPV}, commonly used for filming or racing. It is the most beginner friendly out of the three, because it has a large community, which results in a wide range of tutorials. When a new \gls{Fc} comes out it is normally made to be used with Betaflight. However, Betaflight lacks support for different types of vehicles and generally the automated features are less developed compared to the other two. 
	
	INAV offers basic autonomous flight using waypoints and automated landing. It does not only support quadcopters, but also boats, rovers, planes and wings. It has a similar interface to Betaflight, so switching from one to the other is easier than switching from INAV to Ardupilot.
	
	Ardupilot basically offers everything the other two have to offer and more, for example Submarines and VTOLs. Although it is not commonly used with \gls{FPV}, it is still possible. Ardupilot involves more steps to set up, which also leads to the main benefit of it, namely the nearly limitless customization options.
	% TODO get this sentence to work somehow, that it says that it is more complicated, but this is also the benefit, because of the limitless customization options
	
	It is also the only option to use together with a companion computer like the RaspberryPi. A few years ago it was really expensive to start, because it only supported the Pixhawk family of flight controllers which cost several hundred Franks per piece. However, in recent years it has began to support more and cheaper flight controllers.
	
	\section{Methodology}
	%only what has been done
	\subsection{Drone Overview}
	If you want to fly a drone you have two options available: either you buy one or you build one. The second option is from a technical viewpoint, not only the better option but also the cheaper one.
	
	The main parts needed for a drone are the \gls{Fc}, the \gls{ESC}, the receiver, the battery, servos and of course the mainframe. Additionally a \gls{GPS} and LEDs can be added as needed. The \gls{Fc} and the \gls{ESC} are sometimes more generally referred to as \gls{PCB}\footnote{A \gls{PCB} is a board that consists of electronic components, which are connected through the laced copper wires in board} or simply 'board'. 
	% TODO do footnote better sounds really weird
	The \gls{Fc} runs the chosen software and controls every other part in one way or another. It is directly connected to the \gls{ESC}, which controls the motors and is connected to the battery. The \gls{Fc} also communicates with the receiver and \gls{GPS} if there is one. In this case there will also be a microcomputer, I chose the RaspberryPi, which connects to the \gls{Fc}.
	% TODO add a graphic which illustrates the connection between the parts
	\subsection{Data Transfer Protocols}
	\subsubsection{SPI}
	\subsubsection{Uart}
	\subsubsection{I2C}
	\subsubsection{Mavlink}
	
	
	\subsection{Parts}
	
	\subsubsection[Fc]{Flight Controller}
	There are two different types of flight controllers: the \gls{AIO} and a standalone \gls{Fc}. The \gls{AIO} consists not only a \gls{Fc} but also the \gls{ESC} in one board. This has the advantage of only needing one board instead of two or five, in some alternative setups. However, if only parts of the \gls{ESC} or the \gls{Fc} are damaged you need to replace the whole board, which is more expensive than replacing only the \gls{Fc} or \gls{ESC}. 
	
	Betaflight and INAV both support a wide variety of \glspl{Fc} compared to Ardupilot which is only supporting a very specific sample of boards \cite{FcSupport}. They have the option of open and closed hardware. Because the open hardware \glspl{Fc} are quite expensive, so I decided to go with a closed one. The chip used in \glspl{Fc} is usually a STM32. There are multiple generations of it the mainly used ones are F4, F7 and H7, the newest version is the H7. I then decided to go with the Kakute H7 v1.3 (MPU6000) from Holybro, because it was affordable and available as a stack \cite{KakuteH7}. A stack is a \gls{Fc} and \gls{ESC} mounted on top of each other. It normally comes with stack screws. It comes shipped with Betaflight so it is required to flash Ardupilot. 
	% TODO explanation open and closed hardware




	\subsubsection[ESC]{Electronic Speed Controler}
	There are two different kind of \gls{ESC}s: 4in1 and single \glspl{ESC}. If you use single \gls{ESC}s, then one is needed for each motor instead of a single board for all of them. The advantage of 4in1 \gls{ESC}s is that it does not require a power distribution board, because it is already incorporated in the \gls{ESC}, and that it can come in a stack. The disadvantage is that if a part of the \gls{ESC} is damaged you need to replace the whole board. What needs to be considered before buying a \gls{ESC} is that the peak current of the motor is not higher than the burst current of the \gls{ESC}, because a too high current could damage the \gls{ESC}.
	
	My decision was to go with a 4in1 on a stack, because it is slightly cheaper and normally easier to wire compared to four single boards. The only option with the Kakute H7 was the stack with the Tekko32 4in1 with a continuous current of either 50A, 60A or 65A. I chose the 50A one, because you do not need a high continuous current rating when flying rather slowly and the motors I chose have a peak current of around 42A \cite{Tekko32}. 
	
	At the time I bought the Tekko32, it was still shipped with BLHeli32, which as mentioned in the beginning has since seized their operations. It is however possible to flash AM32\footnote{A different \gls{ESC} software, which has gained quite some popularity after BLHeli32 is off the market.} onto it \cite{AM32}.

	\subsubsection{Motor}
	There are two types of motor: brushed and brushless ones. The difference between the two types is that the brushed motors are mechanically driven, while the brushless motors are electrically driven. Therefore brushless motors also need an ESC to function compared to brushed ones. Brushed motors are used in very small drones with 1S\footnote{What 1S means will be explained in the next section} batteries. However, even in the small drones brushless motors are the more popular choice \cite{brush/lessmotors}. 
	% TODO explain brush/less motors better
	% TODO get a better picture for this
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.2]{pictures/motor}
	\caption{\cite{picturemotor}}
	\label{fig:motor}
\end{figure}

	The numbers that are seen on the motors, such as '2207', describe the stator of the motor itself. In the case of a 2207 that would be a 22mm diameter and a height of 7mm. The usual stator sizes of 5 inch drones are either 2207 or 2306. There is also the KV value, which has to be considered. The KV value is the number of revolutions per minute (rpm) a motor turns when one volt is applied. The lower the KV value, the more efficient the motor is and the higher the KV value the more responsive it is. The KV value for a 5-inch drone with a 4S battery ranges from 2300 to 2800. I chose the Iflight Xing-E Pro 2207\cite{xingepro} with a KV value of 2450, because the IFlight-Xing motors are known to be of good quality, \textit{'they (Xing motors) also prove to be very reliable and most importantly durable'} \textcite{xingreview}. 


	
	\subsubsection{Battery}
	There are two main types of batteries: \gls{LiPo} and \gls{Li-ion} batteries. \gls{LiPo} batteries have a tendency to go up in flames. They have a much higher discharge rate compared to \gls{Li-ion} batteries, also denoted as the C value, so they are well suited for racing drones. However, \gls{Li-ion} batteries have a higher energy density, which means that they can store more mAh for the same weight compared to \gls{LiPo} batteries, so they are more common in long-range flying. The batteries normally have multiple cells, for example a 4S \gls{LiPo} battery contains 4 cells. This is important, because the more cells you have, the higher is the voltage and so you will need a motor with a lower KV value. 
	
	I first wanted to buy two \gls{Li-ion} battery packs, however they are hard to get and much more expensive. The other option would be to solder them together, but it requires some soldering skill, which I personally did not have then. Hence, I decided to go with 4S \gls{LiPo} batteries from the Tattu R-line with 120C and 2000mAh\cite{tattu}, because I wanted something that can fly longer than just three or four minutes. I chose the brand Tattu, because it was the only known brand that was on AliExpress, from where I also sourced all the other components, so it seemed to be easier to also chose a battery from there. 
	
	% TODO \gls from now on	____________________________________

	\subsubsection{GNSS(Global Navigation Satellite System)/Compass}
	There are two different kinds of \gls{GNSS}\footnote{The \gls{GNSS} is usually referred to as \gls{GPS} even though \gls{GPS} is only the American \gls{GNSS} system} modules: the normal \gls{GPS} and compass boards and \gls{RTK} \gls{GPS}. Usually the chips used in both the RTK GPS and the normal GPS are manufactured by the company Ublox. The RTK GPS can achieve an accuracy of 1cm by incorporating information correction data from a \gls{RTCM}\footnote{It was first used for the positions of boats and other vessels}. However, the correction data is either subscription-based, not guaranteed to cover all of the area or one needs to build one by themselves, which is quite complicated \cite{rtkgps}. For a small drone it may not be worth it to have a \gls{RTK} \gls{GPS} that costs several hundred Swiss Franks instead of a \gls{GPS} with a 2m \gls{CEP} which costs less than 30 Swiss Franks. Some of the \gls{GPS} units also have a compass built-in, so you will not need to buy an extra compass when using ArduPilot. 
	\begin{Explanation}[circular error probable (CEP)]
		\item The \gls{CEP} refers to how close to the real value the \gls{GPS} normally is. So if a \gls{GPS} has a \gls{CEP}
		of 2m it is normally in the range of 2 meters of the correct value \cite{CEP}.
	\end{Explanation}
	% TODO better description of the Ublox chip
	
	I chose the Holybro Micro M10 \gls{GPS}, because it is produced by the same brand as the Fc and therefore seemed to be easier to connect \cite{holybrom10micro}. In addition, the M10 chip is the newest version of Ublox chips and it would be pointless to buy an older version at the same price. It also is at least as good as other better-known GPS as the Matek M10Q \cite{gpstest} and comes with a built-in compass that is needed for ArduPilot.

	\subsubsection{Radio/Transmitter}
	The following information about transmitter protocols is based on two YouTube videos from \textcite{transprotocols} and \textcite{mlrs}.
	% TODO explain difference between 900MHz and 2.4 GHz
	% TODO explain latency and range in the beginning of subsubsection
	% TODO delete uneccessary radio protocols
	% TODO i don't know something, forgot...
	\subsubsection*{FrSky}
	There are three FrSky protocols that are not compatible with each other ACCST, ACCESS and FrSky R9 ACCESS. ACCST has a range of around 1-2 km in open air. The firmware is built into almost all radios. It has a good latency but not as good as the other options. ACCESS is the successor to ACCST and has about the same range, but a lower latency, however not a class leading one. FrSky R9 ACCCESS gives you a range of over 50km in ideal condition. Unfortunately, the FrSky ACCESS porotcols are only supported by FrSky radios. There is one problem with FrSky. It is quite a difficult to manage, because of the three protocols that are not compatible with each other.

	\subsubsection*{TBS Crossfire/Tracer and Immersion RC Ghost}
	TBS Crossfire has a range of over 100km and is easy to use. It is also well tested and stable and has a good latency. 
	TBS Tracer can have also over 10km, but drains the battery when flying further away. It is more focused on racing due to the low-latency.
	Immersion RC Ghost as a range of over 10km. It is possible to switch between a low-latency for racing and a high-latency for long range flying. 
	\subsubsection*{ExpressLRS}
	ExpressLRS is the best in long range and in the combination of long range and latency. It has been shown by \textcite{elrswezley}\footnote{Due to him being fined by the Australian government he took down his own video, so only a copy from an other YouTube channel exists.} that it really can fly up to 100km\footnote{There are two version a 900MHz and a 2.4GHz and the main difference is that the 2.4GHz only at least over 30km but unlikely over 100km, but it has the lowest latency compared to any other protocol.}. It is together with mLRS the only two options who are open source.
	\subsubsection*{mLrs}
	The main difference between ExpressLRS and mLRS is that mLRS has a higher latency to send larger data packages to your telemetry device. Which is something that is needed if you want to adjust something or get more data from your drone over the Mavlink protocol during the flight. 
	% TODO explanationbox for Mavlink
	
	\subsubsection*{Transmitter/Radio}
	I've decided to go with the Radiomaster RP4TD ExpressLRS 2.4GHz True Diversity Receiver based on a recommendation of a friend \cite{radiomasterreceiver}. It also is compatible with mLRS if I want to switch later on.
	
	I went with the Radiomaster Boxer\cite{radiomasterboxer} radio, because it is somewhat in the middle range from radios and seems to be quite reliable and has many switches to assign flight modes or other functions to. 

	\subsubsection{Smoke Stopper}
	A smoke stopper is a device that prevents the ESC from short-circuiting due to incorrectly soldered parts and can save quite a lot of money. There are two groups of smoke stoppers one that you buy and get destroyed when the ESC short circuits instead of the ESC. There is another category that does not destroy itself and there are also some that you can solder together on your own\cite{smokestopper}. 
	
	\subsubsection{Problems with the Parts}

	There were mainly two problems that arose during the process of assembling the drone. One less severe than the other. One problem was that my ordered Kakute-Tekko stack did not include stack screws, which they normally do. Stack screws are just screws that you can use to mount the stack onto the frame. So I needed to purchase them separately, which was rather tedious and time-consuming.
	
	The more severe problem I ran into was that the batteries from AliExpress were first withheld by the Swiss border control and then I received two insect traps instead of batteries. Luckily I ordered one of the same batteries from another online shop (Conrad), because the other two took too long to deliver.
	% TODO add pictures of the insect traps 
	
	Two months later, when my father decided to open the insect traps. To our shock, the LiPo batteries were inside the insect traps at the bottom. And in hindsight it was also obvious that they were in there, because it had the numbering 3 4s 2000 on top which stands for version 3 of the 4s batteries with 2000 mAh. However, we dismissed the numbering on top as just some random numbers put there. 
	
	\subsubsection{Propellers and Battery Charger}
	For the propellers and battery chargers, I went off the recommendations from AOS-RC and FPVknowitall. For the propeller, I chose the Foxeer Donut 5145 \cite{toroidal} and the HQ 5x4.3x3 V1S \cite{hqprops}. For the battery charger, I went with the cheapest option the 608 AC Lipo Battery Charger \cite{lipocharger}.

	\subsection{ArduPilot}
	This chapter summarizes everything done for the first time flying and what could go wrong based on my experience. It is based on the ArduPilot copter documentation \cite{ardupilotdocs}.
	
	\subsubsection{Ground Station}
	To configure ArduPilot, there are multiple softwares, so called \gls{GCS} required. They are normally ground-based and can transmit data via wireless telemetry device or USB cable.  With the telemetry device, they can also control the drone from the ground and alter the route as the drone is autonomously flying. 
	
	The most widely used \gls{GCS} is \gls{MP} it is widely used, but runs only on Windows and Mac OS. It also has a wiki, which was used for the first-time configuration of my drone \cite{MissionPlanner}. 
	
	Another GCS is MavProxy it is based on Python and is only for the Linux \gls{OS}. Which is the \gls{OS} that will be used on the RaspberryPi companion computer. 
	\begin{Explanation}[operating system(OS)]
		\item A \gls{OS} is a software, which controls all the hardware of a computer.
	\end{Explanation}

	\subsubsection{Firmware Installation}
	The following section until 4.5 Companion Computer is rather technical and contains the necessary information for the steps to reproduce my setup.
	
	For the first time installation the Kakute H7 is required to be flashed with ArduPilot, because it is shipped with Betaflight. 
	\begin{Explanation}[to flash]
		\item Flashing is the process of taking new firmware and loading it onto the device the firmware is needed on.
	\end{Explanation} 
	To install the ArduPilot firmware for the Kakute H7  it needs to be downloaded onto a computer \cite{ArduPilotFirmware}. Afterwards the STM32CubeProgrammer is used to flash the firmware onto the Fc \cite{STM32CubeProgrammer}. The \gls{Fc} in \gls{DFU} mode is directly connected with the computer using a USB cable. Then the USB port, with which the \gls{Fc} is connected, select and firmware is flashed onto the \gls{Fc} . A reboot is required to leave the \gls{DFU} mode, before connecting the \gls{Fc} to \gls{MP}. The progress of flashing the firmware was straightforward, unlike for the rest of the configuration.
	% TODO read through from here on further
	\begin{Explanation}[device firmware upgrade (DFU)]% no \gls because it looks bad in the text box
		\item The \gls{DFU} mode is the mode, which allows the user to upload new firmware to the \gls{Fc}. It is normally accessible through a button which needs to be pressed, while connecting the battery. 
	\end{Explanation}


	\subsubsection{GPS Connection}
	In the beginning no immediate \gls{GPS} connection appeared. Even changing the parameter \lstinline|GPS_Type = 2| for the Ublox \gls{GPS}, the 'No \gls{GPS}' error, as seen in the bottom right corner of \cref{fig:nogps}, was still there. Even though the it was clear that the \gls{GPS} worked and was connected to the \gls{Fc}, because the compass appeared in the compass calibration tab on \gls{MP}.
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.2]{pictures/No_GPS}
	\caption{No \gls{GPS} connection}
	\label{fig:nogps}
\end{figure}

	The issue could be that the \gls{GPS} is too close to metal surfaces,the Computer, which is connected via USB cable, is too close or that soldering was done poorly and the cables from the \gls{GPS} to the \gls{Fc} are falsely connected. After testing for each of the possible issues and mitigating the proximity in which metal was near the drone, the \gls{GPS} still not working. The GPS itself was also not damaged, because the blue led was blinking constantly which means it is connecting to a \gls{GNSS}.

	The problem was that the \lstinline|Serial3_Protocol| (Which is for the Uart3, which will be used for the connection to the RaspberryPi) was set to 5 which stands for \gls{GPS}, however with that it blocked the Uart4 from being received as a \gls{GPS}, to which the \gls{GPS} was really connected. After disabling the Uart3 it finally worked.

	The GPS is quite precise outside \cref{fig:gpsoutside}\footnote{It also works sometimes inside and is precisely on my room, but it can also show that it is in Poland the middle of the Atlantic Ocean or Iceland.}.
	
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.2]{pictures/GPS_Outsidewithdot}
	\caption{\gls{GPS} outside}
	\label{fig:gpsoutside}
\end{figure}
	
	

	 
	\subsubsection{Receiver/Transmitter}
	To get the connection between the receiver and radio the ExpressLRS page needs to be followed \cite{expresslrsorg}. It required changing the \lstinline|Serial6_Protocol| to 23 and the \lstinline|RSSI_Type| to 3 for the receiver protocol. I also changed the \lstinline|RC_Options| to the correct bitmask (\cref{fig:bitmask}).
% TODO do I really need this picture
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\linewidth]{pictures/bitmask}
	\caption{correct bitmask for ExpressLRS}
	\label{fig:bitmask}
\end{figure}
	The connection between the radio and receiver seemed to be working, because the receiver had a constant blue light and the receiver notified that the telemetry recovered after it was lost for a moment. However, it did not yet have a connection to the Fc. There was the possibility to change the Uart6 ot the Uart1, which is usually the Uart used for receivers with the Kakute H7, but it would require a JST (a special connector) and more soldering. The solution was found in the Kakute H7 tab in the ArduPilot documentation, where it was listed that for a CRSF\footnote{Even though it is a ELRS receiver it has the same interface as CRSF receivers} interface the parameter \lstinline|Brd_Alt_Config| needs to be set to 1. \lstinline|Brd_Alt_Config| is a Fc specific parameter, this is also the reason why it did not come up in the ExpressLRS page or the ArduPilot documentation. 

	\subsubsection{Battery}
	The battery was rather straightforward. The smoke stopper did not light up when plugging it in. Firstly the battery was not recognized by the \gls{Fc}, but it was solved by changing the parameter \lstinline|Batt_Monitor| to 4. After that the voltage and amperage shows up in \gls{MP}.

	\subsubsection{Motor Test}
	The motor test works correct after assigning the right position to the motors, because I'm using the M5-M8 ports instead of the M1-M4. The parameter \lstinline|Mot_PWM_Type| needs to be set to dshot 600. The motor testing works after assigning the correct motor to the correct output in the servo output tab in \gls{MP}. Dshot is the digital protocol for communication between the \gls{Fc} and \gls{ESC}. The motors begin to beep after a certain time, due to the beacon delay. This will be turned of later. This was also the first time the \gls{ESC} had power and through that a new error appeared called 'battery failsafe'. This is caused by a unstable connection between the \gls{ESC} and the \gls{Fc}, because of that the \gls{Fc} takes the computer as power source and has to little power to spin the motors.
	
	\subsubsection{Compass Calibration}
	The compass calibration needs a good \gls{GPS} lock. However, even with a good lock, relaxed fitness\footnote{The fitness can be in four different states very strict, strict, default and relaxed. The stricter the fitness is the longer the calibration takes.} and \lstinline|Compass_Orient| set to 6, as recommended by the Holybro docs, it still failed \cite{HolybroDocs}. Large Metal parts could again influence the calibration, but there were none in the vicinity of the compass. To temporarily do the calibration the large vehicle MagCal can be done. However, this mostly takes away the prearm message. It is strongly advised against by the ArduPilot documentation, because it can look as if it is correctly configured, but the orientation is incorrect. The best way to calibrate the compass is to put the compass directly on  top of the \gls{Fc} and then do the calibration.

	\subsubsection{Road to First Flight}
	The first step to flying is to arm the drone.
	\begin{Explanation}[to arm]
		\item To arm a drone means that the motors begin to spin without producing enough thrust to lift the drone from the ground. It is used when you want to fly before the actual flight.		
	\end{Explanation}
	For that a switch on the radio needs to be assigned to arming and disarming. In my configuration the switch five is used. In order for it to work the parameter \lstinline|RC5_Option| is set to 153, which means to arm the drone when the switch number 5 is flicked. To test the drone on the bench inside there will be many prearm errors to ignore the parameter \lstinline|Arming_Check| is disabled and more importantly the geofence, which still blocks the arming when \lstinline|Arming_Check| is disabled. After this when flicking the switch 5 the motors will arm and spin\footnote{A battery needs to be connected.}. From my experience it is really important to tie down every cable or antenna before arming the drone with propellers, else they might just be cut through or teared off. This will cause a new prearm error to appear called 'crashdump bin detected'. This file can be used to analyze the crashes your drone has had. As long as it is tested on the bench it should not be a problem and can be deleted by flashing new firmware onto the drone \cite{blogcrashdump}. This time however not via STM32CubeProgrammer, but directly over \gls{MP}. Additionally the some of the motors need to be reversed for the X-configuration of the drone, seen in \cref{fig:quadx}. To reverse them the reverse button in \gls{MP} does not work. The BLHeliSuite32 software is needed and the parameter \lstinline|Servo_BLh_Auto| is set to 1 which enables a pass through from the \gls{ESC} through the \gls{Fc}. In the software one can change the motor spinning direction. It is also advisable to turn off beacon delay, at least for now, or else the motors will beep after ten minutes of being idle.
	\begin{Explanation}[beacon delay]
		\item The beeping of the beacon delay is used to located a crashed drone. If the drone has lost the contact to the radio it will automatically activate after a certain amount of time.
	\end{Explanation}
	
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.4]{pictures/quadx}
	\caption{Motor turning directions}
	\label{fig:quadx}
\end{figure}

	After arming the quad and pushing the throttle I was able to get the drone to fly, but it was shaking violently also known as wobbling and then somewhat crashed it into the ground causing minimal damage to propellers. I tried to tighten everything on the drone, because until that point everything was just somewhat loosely taped onto it, the wobbling still continued. Trying new and also the other props, as there could be a prop imbalance that causes the drone to wobble, had no effect. Through a video\cite{dronewobblevideo} about drone wobbling I came to the conclusion that my \gls{PID} values are for a 9 inch drone not a 5 inch drone. 

	\begin{Explanation}[{{proportional, integral, derivative (PID)}}]
		\item The \gls{PID} refers to three variables who control the error adjusting system in a drone. With error is meant the difference between how much the motors rotate and how much they should rotate. 
	\end{Explanation}
	After adjusting them via the intial tuning parameter quick adjustment settings the drone flew. But when I put the stick left the drone flew right and vice versa. I was able to put the \lstinline|RC2_Reversed| to 1, which reversed the controls. 
	
	\subsection{Companion Computer}
	\subsubsection{RaspberryPi Setup}
	
	To let the drone fly on its own a companion computer is needed, because the \gls{Fc} does not have enough power to process more complex operations as autonomous flight.
	
	Choosing the RaspberryPi instead of an other companion computer is advisable, due to it being the most used in drone projects.
	
	The RaspberryPi is not shipped with an microSD card and through that also not with the \gls{OS}. To download the \gls{OS}, the RaspberryPi Imager is used. Through the imager it is possible to create an account for the RaspberryPi,  configure the wifi and the possibility for the \gls{SSH} connection. 

	
	
	To see a desktop instead of only a command line based interface with an \gls{SSH} a \gls{VNC} is used. In this case the recommended option was RealVNC viewer a widely spread \gls{VNC}. For this RealVNC server needs to be installed over the terminal via \lstinline|sudo apt-get realvnc-vnc-server| \cite{ionisvnctutorial}\footnote{realvnc-vnc-viewer only required if you want to see a VNC from the RaspberryPi}.
	
	\subsubsection{MAVProxy Installation}
	The following was based on the MAVProxy Documentation \cite{MavProxydocs} from the ArduPilot website.
	
	First all the needed packages need to be installed through the \lstinline|sudo apt-get install| command. 
	\begin{lstlisting}
sudo apt-get install python3-dev python3-opencv python3-wxgtk4.0 python3-pip python3-matplotlib python3-lxml python3-pygame
pip3 install PyYAML
\end{lstlisting}
	What is not said in the MAVProxy Documentation, is that you need a \gls{venv} and can not download it without one or the this error; \lstinline|error: externally-managed-environment| pops up. To get around this issue you need to create and activate a \gls{venv}.
	\begin{lstlisting}
		python3 -m venv mavproxy-env
		source mavproxy-env/bin/activate
		pip install MAVProxy
	\end{lstlisting} 
	
	
	To connect the drone over MAVProxy it is needed to know how the \gls{Fc} is connected to the Raspberry Pi. The command \lstinline!dmesg | tail! will provide the information.
	
	% TODO insert picture USBRaspPiconnect 
	% TODO visually showing on the picture where it shows the connection 
	The command \lstinline|mavproxy.py --master=/dev/ttyACM0 --baudrate 115200 --aircraft MyCopter|, a error will appear if \lstinline|\ttyUSB0| is used. If the Raspberry Pi is connected over the serial ports, \lstinline|\serial0| is used instead of \lstinline|\ttyACM0| and if the baudrate is changed also take the other one, in this case it would be 921600. If the Raspberry Pi will not have another power source except over the \gls{Fc}, the 5+ V pin on the Raspberry Pi needs to be connected to a 5 volt pin on the \gls{Fc} and additionally a ground pin. There will be a low voltage warning that pops up, but the RaspberryPi works fine. In addition the \lstinline|Serial3_Protocol| needs to be changed to 2 for the Mavlink protocol.
	
	When connected to the \gls{Fc} you can use simple simple commands to change the parameters, as \lstinline|param set arming_check 0|, or to arm the copter with \lstinline|arm throttle|.
	
	\subsubsection{Dronekit}
	It needs to be mentioned that the software dronekit is not maintained very well, as it says in the Github repository \cite{dronekitgithub}.The following is mostly based on the Dronekit Documentation \cite{dronekitdocs}.
	
	
	% TODO fix this listing example so I can reference listing environments more easily
	First the Dronekit library needs to be installed in the \gls{venv} with \lstinline|pip install dronekit|. To create a file in the \gls{venv} over the terminal \lstinline|nano dronekittest.py| is used. Noteworthy is that it is not useful to name the file the same as the library itself, because python will confuse it. In the created document you then can connect the \gls{Fc} to the Raspberry Pi as can be seen in \cref{lst:listing-connection}.
	\begin{lstlisting}[language=Python, style=myPython, caption=Python DroneKit Example, label={lst:listing-connection}]
from dronekit import connect

vehicle = connect('/dev/serial0', baud=912600, wait_ready=True)
\end{lstlisting}
	
	Afterwards an error occurred. 
	\begin{lstlisting}
dronekit/__init__.py" , line 2689, in <module>
class Parameters(collections.MutableMapping, HasObservers):
^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: module 'collections' has no attribute 'MutableMapping'
\end{lstlisting}
	The source of the error is that in python 3.10 the abstract base class, MutapleMapping, was moved from collections to collections.abc. This needs to be changed(\cref{changed line}) in the dronekit source code. Which can be accessed with the the command \cref{sourcecode}\footnote{If it would not be open source, the change(\cref{changed line}) would not be possible}.
	
	\begin{lstlisting}[caption= accessing source code, label=sourcecode]
nano /home/EduPi/mavproxy-env/lib/python3.11/site-packages/dronekit/__init__.py
\end{lstlisting}
	
	\begin{lstlisting}[caption= original source code, language=python, style=myPython]
		class Parameters(collections.MutableMapping, HasObservers):
\end{lstlisting}	
to:
%TODO mark inside the listing the change/write a little bit smoother transition inbetween the inserted points
	\begin{lstlisting}[caption={changed line}, label=changed line, language=python, style=myPython, literate={.abc}{{\color{Green}.abc}}4]
		class Parameters(collections.abc.MutableMapping, HasObservers):
	\end{lstlisting}
	
	After this the program worked flawlessly and it was able to give information from the \gls{Fc} over the terminal. As shown with the example \cref{lst:listing-autopilot}, which 
	
	\begin{lstlisting}[language=python, caption={information retrieval}, label=lst:listing-autopilot, style=myPython]
		print( "Autopilot version: %s" %vehicle.version)
	\end{lstlisting}
	\begin{lstlisting}[caption= output from \cref{lst:listing-autopilot}]
		Autopilot version: APM:Copter-4.5.7
	\end{lstlisting}
	% TODO might move up to the part where all the connections are explained to the RaspberryPi
	% TODO look at the exact connections again 
	%Uart ports are seen as /dev/ttyS0 or as 
	%can be looked at via:
	%\begin{lstlisting}
	%	ls /dev/ttys0
	%\end{lstlisting}
	% TODO might delete this
	%Error: 
	%\begin{lstlisting}
	%	Failed to connect to /dev/ttys0 : [Errno 2] could not open port /dev/ttys0: [Errno 2] No such file or directory: '/dev/ttys0'
	%\end{lstlisting}
	%
	%needed to add 
	%\begin{lstlisting}
	%	sudo usermod -a -G dialout $USER
	%\end{lstlisting}
	which adds dialout so the pins to sudo

	The main problem of the outdated Dronkitpython library is, that the function \lstinline|vehicle.channels|, which should read the channel values from the Radiocontroler, is only returning none. It is a long-known issue and to circumvent it a decorator is used \cite{rcchannelissue}. 
	
	
	% TODO explanation box do this decorator
	\begin{Explanation}[Decorator]
		\item A decorator is a function that modifies the behavior of a function or a class \cite{decorator}.
	\end{Explanation} 
	
	\begin{lstlisting}[language=python, style=myPython, label={lst:decorator}, caption={decorator for channel values}]
		@vehicle.on_message("RC_CHANNELS")
		def rc_channel_listener(vehicle, name, message):
			global latest_rc_channels
			latest_rc_channels = message
		
		def get_rc_channel_value(channel_number):
			global latest_rc_channels
			if latest_rc_channels is None:
				return None
			channel_value = getattr(latest_rc_channels, f"chan{channel_number}_raw", None)
			return channel_value
		
	\end{lstlisting}
	The decorator in \cref{lst:decorator} is already predefined in the Dronekit library. When calling it with \lstinline|@vehicle.on_message("RC_CHANNELS)| and saving it to the global variable latest\_rc\_channels as a dictionary it looks like \cref{lst:message}.
	
	\begin{lstlisting}[label=lst:message, caption={output from decorator in \cref{lst:decorator}\protect\footnote{}}]
		chan{i}_raw : x
	\end{lstlisting}
	\footnotetext{With i being the channel number and x the value the channel receives form the radiocontroler}
	
	trying to get a channel value over dronekitpython... does not work
	
	seeing it over mavproxy via the status command, but not the rc status
	
	is probably a bug in dronekit, might have found the issue in question and a  "solution" for it
	
	after a lot of trial and error I got this which works to retrieve a value from the radio
	\begin{lstlisting}[language=python, style=myPython]
		from dronekit import connect, VehicleMode
		import time
		
		vehicle = connect('/dev/serial0', baud=912600, wait_ready=True)
		
		latest_rc_channels = None
		
		@vehicle.on_message("RC_CHANNELS")
		def rc_channel_listener(vehicle, name, message):
			global latest_rc_channels
			latest_rc_channels = message
		
		def get_rc_channel_value(channel_number):
			global latest_rc_channels
			if latest_rc_channels is None:
				return None
			channel_value = getattr(latest_rc_channels, f"chan{channel_number}_raw", None)
			return channel_value
	\end{lstlisting}
	% TODO add flowchart of the code for what is planned
	
	home coordinates are set every time the vehicle is armed
	
	there is no special dronekit command to set a new home location, however it would be possible to access it over mavlink
	
	\lstinline|vehicle.home_location.lat| gives you the latitude of the home location set by ardupilot while arming the quad.
	
	you can access it in the local frame via \lstinline|vehicle.location.local_frame|
	
	
	reading a file in python and exporting coordinates.
	done by \lstinline|p = Path(__file__).with_name('coordinates.txt')| to get the correct file, which is in the same folder
	
	opening the file via \lstinline|p.open('r')|
	exporting the data...
	using the exported data to create new list for alt/lon/alt coordinate to have all the alt in one list and so on.
	
	
	converting the coordinates from the coordinates.txt to 
	
	trying to let the drone fly with the \lstinline|vehicle.simple_takeoff(Zcoordinate)| command does not work
	
	it worked miraculously after diabling the parameter \lstinline|BRD_Safety_Deflt| and setting the bitmask to zero of the parameter \lstinline|BRD_Safetyoption| 
	this is used to enable or disable the outputs to motors and servos. there is also the parameter \lstinline|BRD_Safety_Mask| which controls which switches can still get through when the safety switch is enabled... So the problem was that the \lstinline|Brd_Safetyoption| was set to be activated when \lstinline|Brd_safety_deflt| was disabled and enabled... so there was nothing except radiocontrol going through to the motors not my script.
	
	\section{Results}
	\section{Discussion and Outlook}
	\section{Conclusion}
	
	\section{References}
	\printbibliography[
		heading=bibintoc,
		title={Bibliography}
	]
	\listoftables
	\listoffigures	
	% TODO do this into the appendix?
	% TODO add list of the parts used in the drone build with links directing to websites used to purchase them
	\section{Table of Figures}
	%(short table on which every figure description with the page number is listed)
	
	\printglossary[type=\acronymtype]
	
\end{document}
