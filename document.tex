\documentclass[svgnames]{article}

\input{preamble.tex}

% Dokument
\begin{document}
\begin{titlepage}

	\begin{center}
	
	\includegraphics[width=0.4\textwidth]{pictures/ksimleelogo}
	\vspace*{17em}
	
	\small
	Matura Paper Fall Semester 2024/2025
	
	\LARGE
	Development \& Construction of an Autonomous Path-Following Drone
	
	\vspace*{0.5em}
	\normalsize
	\textbf{Eduard Felix Scherer, 4a}
	
	Supervised by Cyril Wendel
	\vspace*{\fill}
	
	\normalsize
	Winterthur 2025-01-06
	\end{center}
\end{titlepage}

\newpage
\tableofcontents
% TODO ask if the title page is ok
\newpage
	\section{Introduction}
	
	In the today's world where technology is advancing faster than ever before this Matura paper sheds light on self-built and autonomous drones.
	
	However, it first needs to be defined what a drone even is. According to the Cambridge Dictionary, a drone is defined as: \textit{an aircraft that does not have a pilot but is controlled by someone on the ground} \cite{cambridgedrone}. In this work, the term 'drone' will refer to a quadcopter which is a drone with four motors that lifts off and flies through the power provided by the motors and does not glide like a plane. There is also the term \gls{UAV}, however this is mostly used to describe military grade drones.

	In current conflicts the meanings of \gls{UAV} and quadcopters have become more entangled than ever. The typical hobbyist drone is now widely and effectively used to target enemy forces. In the Ukraine war drones are one of the most effective weapons to use against the Russian aggressor. For example, in this conflict drones are used with thermite canisters attached to them to target the enemies under tree covers \cite{thermitedrones}. Since the war began the drones have become increasingly autonomous. Drone pilots with more advanced setups, are able to simply lock onto the target and let the drone follow and detonate near it \cite{nytimesaidrones}. This increased use in war has also had an impact on the market for components. The most used \gls{ESC} firmware BLHeli\_32 ceased its operation due to laws being passed in Norway that penalised firms that are not able to verify that their products are not used in wars \cite{blhelidead}. However, this is really difficult to do regarding that the \glspl{ESC} are dual-use goods\footnote{Dual-use goods are products that are designed for civilian purposes, but can become deadly weapons in the wrong hands \cite{dualuse}.}.
	
%	Which is really difficult to do regarding that both sides in the Ukraine war are buying the \glspl{ESC} no matter what software is on them.  
	% Would have an additional article about drones that are produced in Switzerland that do the same thing
	
	The goal of this Matura paper is to develop an autonomous path-following drone, where path-following refers to navigating a \gls{GPS} path rather than following a ground path using image recognition. Additionally it should be written so that somebody with no prior knowledge about drones can read, easily understand, and also might reproduce the first part until \cref{companion computer} (Companion Computer). After that first part, having some understanding of python will be useful, but it is not a requirement. However, without prior knowledge, the explanations might be a bit confusing.

	I was first interested in drones when I was in fifth grade and received one as a Christmas present. After that, I also wrote a rather interesting piece about different types of drones in sixth grade, but I lost the interest shortly after. Later on, when I was in the "Gymnasium", I was randomly recommended a drone video on YouTube and began gaining interest again. I initially planned to build a \gls{FPV} drone. Sadly, I never really found the time to build one. When the Matura paper came around I found it to be the perfect opportunity to work with a drone. However, I wanted to do something new, like an autonomous drone, and not just building a \gls{FPV} drone, which can even be bought as a prebuilt commodity.

	\section{Literature Review}\label{literaturereview}
	After extensive internet research it becomes clear that only one kind of a comparable published autonomous drone project exists, one with a \gls{Fc} from the Pixhawk family in connection to a Raspberry Pi \cite{litpixall, litpixgir, litpixins}. However, it is obvious that there are many drone laboratories in the industry and for military purposes (Ukraine war), which do not publish their advances in drone technologies. For example, there are many large firms, like Amazon, that are trying to deliver their packages by drones \cite{amazondrone}.
	
	
	\section{Methodology}
	\subsection{General Software Considerations}

	\subsubsection{Open Source Software}
	The software integration in this Matura Paper is based on \gls{OSS}. \gls{OSS} is a software of which the source code is public. There is an important process known as 'forking', which refers to when a person other than the original developer takes the code and modifies it independently. Through this process, a new branch of the software is created, often referred to as a forked version. The main benefit over closed software is that it is often free of charge, and the source code can be downloaded by everyone and modified as one sees fit. However the downside is that if the development team loses interest, the software will become outdated and may no longer function properly with other systems anymore. Both of these aspects will later be found useful and time-consuming. 
	
	\subsubsection{Flight Softwares}
	Based on the literature reviewed there are three main software stacks to consider when it comes to drones: Betaflight, \myinav (\glsentrylong{INAV}), and Ardupilot  \cite{history}. All of them are open source. Multiwii is the origin of Betaflight and \gls{INAV}. Multwii was Arduino based and then upgraded to Baseflight to be able to utilize a better chipset. Then it was forked to Cleanflight, which was later forked again into Betaflight and \gls{INAV}
	
	The following overview of the three softwares, is mostly based on an article written by \textcite{firmwarearticle} and a video made by \textcite{firmwarevideo}.
	
	Betaflight appears to be the go-to option for \gls{FPV}, commonly used for filming or racing. It is the most beginner friendly out of the three, because it has a large community, which results in a wide range of tutorials. When a new \gls{Fc} comes out it is normally made to be used with Betaflight. However, Betaflight lacks support for different types of vehicles and generally the automated features are less developed compared to the other two. 
	
	\gls{INAV} offers basic autonomous flight capabilities, including waypoints and automated landing. It does not only support quadcopters, but also boats, rovers, planes and wings. It has a similar interface as Betaflight, so switching from one to the other is easier than switching from \gls{INAV} to Ardupilot.
	
	Ardupilot basically offers everything the other two have to offer and more, for example submarines and \glspl{VTOL}. Although it is not commonly used with \gls{FPV}, it is still possible. Ardupilot involves more steps to set up, which also leads to the main benefit of it, namely the nearly limitless customization options.

	
	It is also the only option to use together with a companion computer like the Raspberry Pi. A few years ago it was really expensive to start, because it only supported the Pixhawk family of flight controllers which cost a few hundred Francs per piece. However, in recent years it has began to support more and cheaper flight controllers.
	


	\subsection{Drone Overview}
	If someone wants to fly a drone, they have two options available: either they buy one or build one. In the case of autonomous drones, however, the first option is not available. This leaves only the option of building one yourself, compared to \gls{FPV} drones, which can be bought as a prebuilt commodity. 
	
	The main parts needed for a drone are the \gls{Fc}, the \gls{ESC}, the receiver, the battery, servos and of course the mainframe. Additionally a \gls{GPS} and LEDs can be added as needed. The \gls{Fc} and the \gls{ESC} are sometimes more generally referred to as \glspl{PCB}\footnote{A \gls{PCB} is a flat board that houses electronic components and features conductive pathways etched onto its surface to connect those components.} or simply 'boards'.


	The \gls{Fc} runs the chosen software and controls every other part in one way or another. It is directly connected to the \gls{ESC}, which controls the motors and is connected to the battery. The \gls{Fc} also communicates with the receiver and, if present, the \gls{GPS}. In this case there will also be a Raspberry Pi, as companion computer, which connects to the \gls{Fc}. The connections between the parts are shown in \cref{fig:connectionscorrect2} and in \cref{fig:assembleddrone} one can see the completely assembled drone.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\linewidth]{pictures/connectionscorrect2}
	\caption{connection between the parts inclusive the data transfer protocols}
	\label{fig:connectionscorrect2}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\linewidth]{pictures/assembleddrone}
	\caption{assembled drone}
	\label{fig:assembleddrone}
\end{figure}
	\subsection{Data Transfer Protocols}
	There are two types of data transfer protocols: serial and parallel. They transfer data is by pulsing 5V for a 1 and 0V for a 0. The difference is that the parallel communication sends the data for each bit parallel to the other 7 bits through eight connections, as seen in \cref{parallel}, and the serial sends the data over one connection. This kind of data transfer requires a clock to synchronize the output of data.

	\begin{figure}[ht]
		\centering
		\begin{minipage}[c]{0.4\textwidth}
			\includegraphics[width=\textwidth]{pictures/SPIparallel}
			\caption{parallel communication of the letter "C" \cite{spiprotocol}}
			\label{parallel}
		\end{minipage}
		\hfill
		\begin{minipage}[c]{0.4\textwidth}
			\includegraphics[width=\textwidth]{pictures/SPIserial}
			\caption{serial communication of the letter "C" \cite{spiprotocol}}
			\label{serial}
		\end{minipage}
	\end{figure}
	
	\subsubsection{UART}
	The \gls{UART} is a physical circuit \cite{uartprotocol}. In the field of self-built drones it is used to communicate to and from the \gls{Fc} to the \gls{GPS} and receiver, as shown in \cref{fig:connectionscorrect2}. It works by transmitting data asynchronously. Instead it has a so-called baud rate, which is a measure of \gls{bps}. When connecting two \gls{UART} microcontrollers there are two lines needed from the Tx of one to the Rx of the other and vice versa, as shown in \cref{fig:uartconnection}. With a \gls{UART} a data packet is transferred instead of individual bits. The packet consists of a start bit, followed by 5 to 9 data bits and at the end there are 1 to 2 stop bits, as shown in \cref{fig:uartpackage}. There is also the option to include a parity bit instead of one of the data bits. A parity bit is used to verify that none of the bits were changed during the transfer. It is a 0 if the number of 1 in the sequence is even and a 1 if it is odd.
\begin{figure}[ht]
	\begin{minipage}[c]{0.4\textwidth}
		\includegraphics[width=\textwidth]{pictures/UARTconnection}
		\caption{\gls{UART} connection \cite{uartprotocol}}
		\label{fig:uartconnection}
	\end{minipage}
	\hfill
	\begin{minipage}[c]{0.4\textwidth}
		\includegraphics[width=\textwidth]{pictures/Uartpackage}
		\caption{\gls{UART} packet \cite{uartprotocol}}
		\label{fig:uartpackage}
	\end{minipage}
	
\end{figure}

	\subsubsection{I2C}
	The \gls{I2C} communication is also serial like \gls{UART}, but it has the advantage of being able to communicate to more than one slave\footnote{The relationship between two parts where one controls the other is called a master-slave relationship \cite{i2cprotocol}. Obviously the master is the one that controls the slave. Although the terminology is rather controversial, it is still widely used \cite{masterslave}.}. In this work, it is used for the connection between the \gls{Fc} and the compass, which is built into the \gls{GPS}, as shown in \cref{fig:connectionscorrect2}. There are two lines between the master and the slave; the \gls{SDA} and the \gls{SCL}. The \gls{SCL} line is used for synchronization and the \gls{SDA} line for the transfer of a message. The message looks quite different to the one from the \gls{UART}. There is a start condition, afterwards the address frame is used to figure out to which slave the message is addressed to, followed by a bit to determine if the master sends or requests data, the data is followed by a ACK/NACK\footnote{ACK stands for acknowledgment and NACK for negative acknowledgment} bit, which confirms either that the data frame was received or not, and at the end there is a stop condition.
\begin{figure}[ht]
	\begin{minipage}[c]{0.4\textwidth}
		\includegraphics[width=\textwidth]{pictures/I2Cconnection}
		\caption{\gls{I2C} connection \cite{i2cprotocol}}
		\label{fig:I2Cconnection}
	\end{minipage}
	\hfill
	\begin{minipage}[c]{0.4\textwidth}
		\includegraphics[width=\textwidth]{pictures/I2Cpackage}
		\caption{\gls{I2C} message \cite{i2cprotocol}}
		\label{fig:I2Cpackage}
	\end{minipage}
\end{figure}
	\subsubsection{MAVLink}
	The MAVLink protocol is more complex compared to \gls{UART} or \gls{I2C}. It can transfer up to 263 bytes or 280 bytes, depending on the version used. It is used for the connection between the \gls{Fc} and a \gls{GCS} or in this case the Raspberry Pi companion computer, as shown in \cref{fig:connectionscorrect2}.
	\subsection{Parts}
	
	\subsubsection[Fc]{Flight Controller}
	There are two different types of flight controllers: the \gls{AIO} and a standalone \gls{Fc}. The \gls{AIO} consists not only a \gls{Fc} but also the \gls{ESC} on the same board. This has the advantage of only needing one board instead of two or five, in some alternative setups. However, if only a part of the \gls{ESC} or the \gls{Fc} is damaged you need to replace the whole board, which is more expensive than replacing only the \gls{Fc} or \gls{ESC}. 
	
	Betaflight and \gls{INAV} both support a wide variety of \glspl{Fc} compared to Ardupilot which is only supporting a very specific sample of boards \cite{FcSupport}. They have the option of open and closed hardware. Because the open hardware \glspl{Fc} are quite expensive the decision was made to go with a closed hardware \gls{Fc}. The chip used in \glspl{Fc} is usually a STM32. There are multiple generations of it the mainly used ones are F4, F7 and H7, the newest version is the H7. The Kakute H7 v1.3 (MPU6000) from Holybro was then finally choosen, because it was affordable and available as a stack \cite{KakuteH7}. A stack is a \gls{Fc} and \gls{ESC} mounted on top of each other and normally comes with stack screws. It is shipped with Betaflight so it is required to flash Ardupilot. 
	\begin{Explanation}[open and closed hardware]
		\item Like open source software, the "source code" -or in this case blueprints- open hardware can be freely accessed or bought by everyone and adjusted to meet one's individual needs \cite{openhardware}.
	\end{Explanation}




	\subsubsection[ESC]{Electronic Speed Controler}
	There are two different kind of \gls{ESC}s: 4in1 and single \glspl{ESC}. If you use single \gls{ESC}s, then one is needed for each motor instead of a single board for all of them. The advantage of 4in1 \gls{ESC}s is that they do not require a power distribution board, because it is already incorporated in the \gls{ESC}, and that they can come in a stack. The disadvantage is that if a part of the \gls{ESC} is damaged you need to replace the whole board. What needs to be considered before buying a \gls{ESC} is that the peak current of the motor is not higher than the burst current of the \gls{ESC}, because a too high current could damage the \gls{ESC}.
	
	The decision was made to go with a 4in1 \gls{ESC} on a stack because it is slightly cheaper and normally easier to wire compared to four single boards. The only option with the Kakute H7 was the stack with the Tekko32 4in1 with a continuous current of either 50A, 60A or 65A \cite{Tekko32}. The 50A version is already enough, because on one hand one does not need a high continuous current rating when flying slowly and on the other the chosen motors have a peak current of around 42A. 
	
	At the time the Tekko32 was bought, it was still shipped with BLHeli32, which as mentioned in the beginning has since seized their operations. It is however possible to flash AM32\footnote{A different \gls{ESC} software, which has gained quite some popularity after BLHeli32 is off the market.} onto it \cite{AM32}.

	\subsubsection{Motor}
	There are two types of motors: brushed and brushless ones. Brushed motors are used in very small drones with 1S\footnote{What 1S means will be explained in the next section} batteries. However, even in smaller drones brushless motors are the more popular choice \cite{brush/lessmotors}. A brushed motor, as shown on the left in \cref{fig:brushedbrushlessmotor}, works by having two brushes that are delivering the power to a coil in the middle of a permanent magnet. This creates a magnetic field around the coiled, which is then attracted to the magnet surrounding it. Due to the commutator the direction in which the provided electricity flows is changed every half turn. This causes the magnetic field around the coil to change the direction and in turn gets attracted to the other side of the magnet. A brushless motor, as shown in \cref{fig:brushedbrushlessmotor} on the right, works by having a field magnet in the middle and coils surrounding it. The coils surrounding the magnet are part of the so-called stator. These coils are provided with a positive and negative voltage, which will cause the magnetic field around them to alternate. When the alternation is synchronized, which is done by an \gls{ESC}, it will cause the field magnet to spin. 
\begin{figure}[ht]
	\includegraphics[width=0.9\columnwidth]{pictures/brushed_brushlessmotor}
	\caption{brushed and brushless motors \cite{brushlessedmotor}}
	\label{fig:brushedbrushlessmotor}
\end{figure}

	The numbers that are seen on the motors, such as '2207', describe the stator of the motor itself. In the case of a 2207 that would be a 22mm diameter and a height of 7mm. The usual stator sizes of 5 inch drones are either 2207 or 2306. There is also the KV value, which has to be considered. The KV value is the number of revolutions per minute (rpm) a motor turns when one volt is applied. The lower the KV value, the more efficient the motor is and the higher the KV value the more responsive it is. The KV value for a 5-inch drone with a 4S battery ranges from 2300 to 2800. The decision was made to use the Iflight Xing-E Pro 2207  with a KV value of 2450, because the IFlight-Xing motors are known to be of good quality \cite{xingepro}, \textit{'they (Xing motors) also prove to be very reliable and most importantly durable'} \textcite{xingreview}. 

	
	\subsubsection{Battery}
	There are two main types of batteries: \gls{LiPo} and \gls{Li-ion} batteries. \gls{LiPo} batteries have a tendency to go up in flames\footnote{This happens due to unnoticed physical damage, manufacturing defects, improper storage or incorrect charging \cite{lipofires}.}. They have a much higher discharge rate compared to \gls{Li-ion} batteries, also denoted as the C value, so they are well suited for racing drones. However, \gls{Li-ion} batteries have a higher energy density, which means that they can store more mAh for the same weight compared to \gls{LiPo} batteries, so they are more common in long-range flying. The batteries normally have multiple cells, for example a 4S \gls{LiPo} battery contains 4 cells. This is important, because the more cells you have, the higher is the voltage and so you will need a motor with a lower KV value. 

	 
	The initial idea was to buy two \gls{Li-ion} battery packs, however they are hard to get and much more expensive. The other option would be to solder them together in parallel, but it requires some soldering skill, which I personally did not have at the time. Hence it was decided to go with 4S \gls{LiPo} batteries from the Tattu R-line with 120C and 2000mAh, because it needs to, in addition to the \gls{Fc}, power the Raspberry Pi aswell and testing the drone is rather tedious, when one needs to go back to charge every few minutes \cite{tattu}. The brand Tattu was chosen, because it was the only known brand that was on AliExpress, from where all the other components were sourced, so it seemed to be easier to chose a battery from there. 

	\subsubsection{GNSS(Global Navigation Satellite System)/Compass}
	There are two different kinds of \gls{GNSS}\footnote{The \gls{GNSS} is usually referred to as \gls{GPS} even though \gls{GPS} is only the American \gls{GNSS} system} modules: the normal \gls{GPS} and compass boards and \gls{RTK} \gls{GPS}. Usually the chips used in both the RTK GPS and the normal GPS are manufactured by a company called Ublox. The RTK GPS can achieve an accuracy of 1cm by incorporating information correction data from a \gls{RTCM}\footnote{It was first used to determine the position of maritime vessels}. However, the correction data is either subscription-based, not guaranteed to cover all of the area or one needs to build one by themselves, which is quite complicated \cite{rtkgps}. For a small drone it may not be worth it to have a \gls{RTK} \gls{GPS} that costs several hundred Swiss Francs instead of a \gls{GPS} with a 2m \gls{CEP} which costs less than 30 Swiss Francs. Some of the \gls{GPS} units also have a compass built-in, so one does not need to buy an extra compass when using ArduPilot. 
	\begin{Explanation}[circular error probable (CEP)]
		\item The \gls{CEP} refers to how close to the real value the \gls{GPS} normally is. So if a \gls{GPS} has a \gls{CEP}
		of 2m it is normally in the range of 2 meters of the correct value \cite{CEP}.
	\end{Explanation}
	
	The decision was made to use the Holybro Micro M10 \gls{GPS}, because it is produced by the same brand as the Fc and therefore seemed to be easier to connect \cite{holybrom10micro}. In addition, the M10 chip is the newest version of Ublox chips and it would be pointless to buy an older version at the same price. It also is at least as good as other better-known GPS as the Matek M10Q and comes with a built-in compass that is needed for ArduPilot \cite{gpstest}.

	\subsubsection{Radio/Transmitter}
	The following information about transmitter protocols is based on two YouTube videos from \textcite{transprotocols} and \textcite{mlrs}.
	
	The two things to consider when it comes to transmitter protocols are latency and range. Latency is the delay between the input of the radio controller and when the \gls{Fc} reacts. The lower the latency, the faster the drone will react, to the inputs from the radiocontroler. It is related to the frequency bands of the receiver, of which there are normally two: 900 MHz and 2.4 GHz. When both are optimized the 900 MHz has better penetration and range, due to the longer wavelength, while the 2.4 GHz has a higher latency, because the frequency allows for faster data transmission.

	\subsubsection*{ExpressLRS\protect\footnote{The LRS stands for long range system.}}
	ExpressLRS is the best protocol in long range and in the combination of long range and low latency. It has been proven by \textcite{elrswezley}\footnote{Due to him being fined by the Australian government he took down his own video, so only a copy from an other YouTube channel exists.} that it can fly up to 100km away from the starting point. There are two version: a 900 MHz and a 2.4 GHz. The main difference is that the 2.4 GHz can reach over 30km, but it is unlikely to go to 100km. However, it has the lowest latency, even when compared to other protocols. Together with mLRS it is the only protocol that is open-source.
	% TODO at the end check if this footnote still references the one from ExpressLRS
	\subsubsection*{mLRS\textsuperscript{\hyperlink{footnote9}{10}}}
	The main difference between ExpressLRS and mLRS is that mLRS has a higher latency, which allows it to send more data to your telemetry device. This is needed if you want to adjust something or receive more data from your drone over the MAVLink protocol during the flight. 
	
	\subsubsection*{Transmitter/Radio}
	The decision was made to go with the Radiomaster RP4TD ExpressLRS 2.4GHz True Diversity Receiver based on a recommendation from friend \cite{radiomasterreceiver}. It is also compatible with mLRS if it is needed later on.
	
	The decision was made to go with the Radiomaster Boxer radio, because it is somewhat in the middle range from radios and seems to be quite reliable and has many switches to assign flight modes or other functions too  \cite{radiomasterboxer}. 

	\subsubsection{Smoke Stopper}
	A smoke stopper is a device that prevents the ESC from short-circuiting due to incorrectly soldered parts and can save quite a lot of money  \cite{smokestopper}. There are two groups of smoke stoppers one that you buy and is destroyed when the ESC short circuits instead of the ESC. There is another category that does not destroy itself and there are also some that you can solder together on your own. 
	
	\subsubsection{Propellers and Battery Charger}
	For the propellers and battery chargers, the recommendations from AOS-RC and FPVknowitall were used \cite{aosrc, fpvknowbattery}. For the propellers the Foxeer Donut 5145  and the HQ 5x4.3x3 V1S \cite{toroidal, hqprops} were chosen. And as the battery charger, the cheapest option, the 608 AC Lipo Battery Charger, was decided to be used \cite{lipocharger}.


	\subsubsection{Problems with the Parts Procurement}
	There were mainly two problems that. The first problem was that my ordered Kakute-Tekko stack did not include stack screws, which they normally do. Stack screws are just screws that you can use to mount the stack onto the frame. So I needed to purchase them separately, which was rather tedious and time-consuming.
	
	The more severe problem I ran into was that the batteries from AliExpress were first withheld by the Swiss border control and then I received two insect traps instead of batteries. Luckily I ordered one of the same batteries from another online shop (Conrad), because the other two took too long to deliver.
	
	Two months later, when my father decided to open the insect traps. To our surprise, the \gls{LiPo} batteries were inside the insect traps at the bottom. And in hindsight it was also obvious that they were in there, because it had the numbering 3 4s 2000 on top which stands for version 3 of the 4s batteries with 2000 mAh. However, we dismissed the numbering on top as just some random numbers put there. 
	

	\subsection{ArduPilot}
	This chapter summarizes everything done for the first time flying and what could go wrong is based on my experience and the ArduPilot copter documentation \cite{ardupilotdocs}.
	
	\subsubsection{Ground Station}
	To configure ArduPilot, there are multiple softwares, so called \gls{GCS} required. Usually they are ground-based and can transmit data via wireless telemetry device or USB cable.  With the telemetry device, they are able to control the drone from the ground and alter the route as the drone is autonomously flying. 
	
	The most widely used \gls{GCS} is \gls{MP}, but runs only on Windows and Mac OS \cite{MissionPlanner}. It has a wiki, which was used for the first-time configuration of my drone. 
	
	Another \gls{GCS} is MavProxy. It is written in python and intended to be used on Unix-based systems. MavProxy will be used to test the connection between the \gls{Fc} and the Raspberry Pi, which is using the Debian \gls{OS}, a Unix-based system.
	\begin{Explanation}[operating system(OS)]
		\item A \gls{OS} is a software, which controls all the hardware of a computer.
	\end{Explanation}

	\subsubsection{Firmware Installation}
	The following section until \cref{companion computer} (Companion Computer) is rather technical and contains the necessary information for the steps to reproduce my setup.
	
	For the first time installation, the Kakute H7 is required to be flashed with ArduPilot, because it is shipped with Betaflight. 
	\begin{Explanation}[to flash]
		\item Flashing is the process of taking new firmware and loading it onto the device the firmware is needed on.
	\end{Explanation} 
	To install the ArduPilot firmware on the Kakute H7  it needs to be downloaded onto a computer \cite{ArduPilotFirmware}. Afterwards the STM32CubeProgrammer is used to flash the firmware onto the Fc \cite{STM32CubeProgrammer}. The \gls{Fc} in \gls{DFU} mode is directly connected with the computer, using a USB cable. Then the USB port, with which the \gls{Fc} is connected, is select and firmware is flashed onto the \gls{Fc} . A reboot is required to leave the \gls{DFU} mode, before connecting the \gls{Fc} to \gls{MP}. The progress of flashing the firmware was straightforward, unlike the rest of the configuration.

	
	\begin{Explanation}[device firmware upgrade (DFU)]% no \gls because it looks bad in the text box
		\item The \gls{DFU} mode is the mode, which allows the user to upload new firmware to the \gls{Fc}. It is normally accessible through a button which needs to be pressed, during startup.
	\end{Explanation}


	\subsubsection{GPS Connection}
	In the beginning no immediate \gls{GPS} connection appeared. Even changing the parameter \lstinline|GPS_Type = 2| for the Ublox \gls{GPS}, the 'No \gls{GPS}' error, as seen in the bottom right corner of \cref{fig:nogps}, still occurred. Even though it was clear the \gls{GPS} was working and connected to the \gls{Fc}, because the compass, which is part of the \gls{GPS}, appeared in \gls{MP} and the \gls{GPS} blinked blue, indicating a connection to a \gls{GNSS}.
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.2]{pictures/No_GPS}
	\caption{No \gls{GPS} connection}
	\label{fig:nogps}
\end{figure}

	The issue could be that the \gls{GPS} is too close to metal surfaces, the computer, which is connected via USB cable, is too close, that the soldering was done poorly, or the cables from the \gls{GPS} to the \gls{Fc} are falsely connected. After testing for each of the possible issues and mitigating the proximity in which metal was near the drone, the \gls{GPS} was still not working.

	The problem was that the \lstinline|Serial3_Protocol| (which is for the Uart3 that will be used for the connection to the Raspberry Pi) was set to 5 which stands for \gls{GPS}. However, this blocked the Uart4, to which the \gls{GPS} is connected, from being received as a \gls{GPS}. After disabling Uart3 it finally worked.

	The GPS is quite precise outside \cref{fig:gpsoutside}\footnote{It sometimes works inside and is precisely on my room, but it might also show that it is in Poland, the middle of the Atlantic Ocean, or Iceland.}.
	
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.2]{pictures/GPS_Outsidewithdot}
	\caption{\gls{GPS} outside, the red point shows the real position}
	\label{fig:gpsoutside}
\end{figure}
	
	

	 
	\subsubsection{Receiver/Transmitter}
	To establish the connection between the receiver and radio the ExpressLRS page needs to be followed \cite{expresslrsorg}. It required changing the \lstinline|Serial6_Protocol| to 23 and the \lstinline|RSSI_Type| to 3 so it can be the receiving end. The \lstinline|RC_Options| needed to be changed as well to the correct bitmask (\cref{fig:bitmask}).

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\linewidth]{pictures/bitmask}
	\caption{correct bitmask for ExpressLRS}
	\label{fig:bitmask}
\end{figure}

	The connection between the radio and receiver seemed to be working, because the receiver had a constant blue light. In addition the radio confirmed the connection, by notifying that the telemetry has been recovered after it was lost for a moment. However, it did not yet have a connection to the Fc. There was the possibility to change the Uart6 to the Uart1, which is usually the Uart used for receivers with the Kakute H7, but it would require a JST (a special connector) and more soldering. The solution was found in the Kakute H7 tab in the ArduPilot documentation, in which was written, that for a CRSF\footnote{Even though it is a ELRS receiver it has the same interface as CRSF receivers} interface the parameter \lstinline|Brd_Alt_Config| needs to be set to 1. \lstinline|Brd_Alt_Config| is a Fc specific parameter, this is also the reason why it did not come up in the ExpressLRS page or the ArduPilot documentation. 

	\subsubsection{Battery}
	The smoke stopper did not light up when plugging the battery in. In the beginning the battery was not recognized by the \gls{Fc}, but this was solved by changing the parameter \lstinline|Batt_Monitor| to 4. After which the voltage and amperage showed up in \gls{MP}.

	\subsubsection{Motor Test}
	The motor test worked correct after assigning the right position to the motors. Which needed to be done, in this setup the ports M5-M8 are used, instead of the M1-M4. Additionally the parameter \lstinline|Mot_PWM_Type| needs to be set to \mydshot 600. \Gls{DShot} is the digital protocol for communication between the \gls{Fc} and \gls{ESC}. The motors began to beep after a certain time, due to the beacon delay. This will be turned of later. This was also the first time the \gls{ESC} had power, because of this a new error appeared called 'battery failsafe'. This is caused by an unstable connection between the \gls{ESC} and the \gls{Fc}, which causes the \gls{Fc} to take the USB cable from the computer as power source and has through that too little power to spin the motors, as they need a higher voltage than provided by the computer.
	
	\subsubsection{Compass Calibration}
	The compass calibration needs a good \gls{GPS} lock. However, even with a good lock, relaxed fitness\footnote{The fitness can be in four different states very strict, strict, default and relaxed. The stricter the fitness is the longer the calibration takes.}, and \lstinline|Compass_Orient| set to 6, as recommended by the Holybro docs, it failed \cite{HolybroDocs}. Large metal parts could again influence the calibration, but there were none in the vicinity of the compass. To temporarily do the calibration the large vehicle MagCal\footnote{The compass calibration is done by rotating the copter in the air. However, this is not really an option for larger vehicles, to calibrate them the large vehicle MagCal is used, by just putting in the direction the compass is facing.} can be done. However, this mostly takes away the prearm message. It is strongly discouraged by the ArduPilot documentation, because it can look as if it is correctly configured, but the orientation is incorrect. The best way to calibrate the compass is to put it directly on  top of the \gls{Fc} and then do the calibration.

	\subsubsection{Road to First Flight}
	The first step to flying is to arm the drone.
	\begin{Explanation}[to arm]
		\item To arm a drone means that the motors begin to spin without producing enough thrust to lift the drone from the ground. It is a safety measure, to prevent the motors from accidentally spinning, when working on the drone and touching the radio.
	\end{Explanation}
	For that a switch on the radio needs to be assigned to arming and disarming. In my configuration  switch five is used. In order for it to work the parameter \lstinline|RC5_Option| is set to 153, which means to arm the drone when switch five is flicked. To test the drone on the bench inside there will be many prearm errors, to ignore them the parameter \lstinline|Arming_Check| is disabled and more importantly the geofence, which still blocks the arming, even when \lstinline|Arming_Check| is disabled. After this if switch five is flicked the motors will arm\footnote{A battery needs to be connected.}. It is really important to tie down every cable or antenna before arming the drone with propellers, else they might just be cut or teared off. This will cause a new prearm error to appear called 'crashdump bin detected'. Which is a file that is created when the drone crashes and can be used to analyze the crashes your drone has had. As long as it is tested on the bench, it should not be a problem and can be deleted by flashing new firmware onto the drone \cite{blogcrashdump}. This time however not via STM32CubeProgrammer, but directly over \gls{MP}. Additionally some of the motors need to be reversed for the X-configuration of the drone, seen in \cref{fig:quadx}. To reverse them the reverse button in \gls{MP} does not work. The BLHeliSuite32 software is needed and the parameter \lstinline|Servo_BLh_Auto| is set to 1 which enables a pass through from the \gls{ESC} through the \gls{Fc}. In the software, one can change the motor spinning direction. It is also advisable to turn off beacon delay, at least for now, or else the \gls{ESC} will beep after ten minutes of being idle.
	\begin{Explanation}[beacon delay]
		\item The beeping of the beacon delay is used to located a crashed drone. If the drone has lost the contact to the radio it will automatically activate after a certain amount of time.
	\end{Explanation}
	
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.4]{pictures/quadxcopy}
	\caption{Motor turning directions}
	\label{fig:quadx}
\end{figure}

	In the first test flight the drone was shaking violently, which is also known as wobbling. This caused the drone to crash  into the ground. Reasons for this behavior can be loosely fastened parts, imbalanced propellers, or wrong parameters used for the \gls{PID} controller \cite{dronewobblevideo}. In this case those parameters were for a 9-inch drone and not a 5-inch. The parameters can be adjusted via the initial tuning parameter tab in \gls{MP}. After this the drone flew fine, except that the sticks of the radio controller needed to be reversed, because when one pulled the stick left the drone flew to the right. This can be done using the \lstinline|RC2_Reversed| parameter.

	\begin{Explanation}[{{proportional, integral, derivative (PID)}}]
		\item The three parameters are used as weights for the three parts (\gls{PID}) of the error function.
	\end{Explanation}
	
	\subsection{Companion Computer}\label{companion computer}
	The following section is rather technical and can be used as a reference to reproduce the combination of the Kakute H7 and a Raspberry Pi working together using Dronekit python.
	\subsubsection{Raspberry Pi Setup}
	
	To let the drone fly on its own a companion computer is needed. Due to the \gls{Fc} does not having enough power to process more complex operations such as autonomous flight.
	
	Choosing the Raspberry Pi instead of another companion computer is advisable, due to it being the most popular in autonomous drone projects. However, such projects are rarely published as mentioned in \cref{literaturereview} (Literature Review).
	
	The Raspberry Pi is not shipped with a microSD card and through that also not with the \gls{OS}. To download the \gls{OS}, the Raspberry Pi Imager is used. Through the imager it is possible to create an account for the Raspberry Pi,  configure the WiFi and the possibility for a \gls{SSH} connection. 

	
	To see a desktop instead of only a command line based interface with an \gls{SSH} a \gls{VNC} is used. In this case the recommended option was RealVNC viewer a widely used \gls{VNC} \cite{ionisvnctutorial}. To be able to use RealVNC, RealVNC server needs to be installed over the terminal via \lstinline|sudo apt-get realvnc-vnc-server|\footnote{\lstinline|realvnc-vnc-viewer| is only required if you want to see a VNC from the Raspberry Pi}.
	
	\subsubsection{MAVProxy Installation}
	The following was based on the MAVProxy Documentation from the ArduPilot website  \cite{MavProxydocs}.
	
	Firstly all the necessary packages need to be installed through the \lstinline|sudo apt-get install| command. 
	\begin{lstlisting}
		sudo apt-get install python3-dev python3-opencv python3-wxgtk4.0 python3-pip python3-matplotlib python3-lxml python3-pygame
		pip3 install PyYAML
	\end{lstlisting}

	What is not said in the MAVProxy Documentation, is that you need a \gls{venv} and cannot download it without one or the error; \lstinline|error: externally-managed-environment| pops up. To get around this issue you need to create and activate a \gls{venv}.
	\begin{lstlisting}
		python3 -m venv mavproxy-env
		source mavproxy-env/bin/activate
		pip install MAVProxy
	\end{lstlisting} 
	
	
	To connect the drone over MAVProxy it needs to know how the \gls{Fc} is connected to the Raspberry Pi. The command \lstinline!dmesg | tail! will provide the information, as seen in \cref{fig:usbrasppiconectrectangle}.

\begin{figure}[th]
	\centering
	\includegraphics[width=0.7\linewidth]{pictures/USBRaspPiconect_rectangle}
	\caption{output from \lstinline!dmesg | tail!}
	\label{fig:usbrasppiconectrectangle}
\end{figure}

	
	The command \lstinline|mavproxy.py --master=/dev/ttyACM0 --baudrate 115200 --aircraft MyCopter|, is used to connect over MavProxy, an error will appear if \lstinline|\ttyUSB0| instead of \lstinline|\ttyACM0| is utilized. If the Raspberry Pi is connected over the serial ports, \lstinline|\serial0| is used instead of \lstinline|\ttyACM0|. The baudrate can also vary, in this case it is 921600. The Raspberry Pi will not have another power source except over the \gls{Fc}. The 5+ V pin on the Raspberry Pi is connected to a 5 volt pin on the \gls{Fc} and additionally a ground pin. There can be a low voltage warning, even though the Raspberry Pi is not receiving enough power, it is sufficient to run Dronekit python code. In addition the \lstinline|Serial3_Protocol| needs to be changed to 2 for the MAVLink protocol.
	
	When connected to the \gls{Fc} you can use simple commands to change the parameters, as \lstinline|param set arming_check 0|, or to arm the copter with \lstinline|arm throttle|. This shows that the connection between the \gls{Fc} and Raspberry Pi is working and one can advance further to Dronekit.
	
	\subsubsection{Dronekit}
	It first needs to be mentioned that the Dronekit python software is not maintained very well, as stated in the Github repository \cite{dronekitgithub}. Even though outdated, the following is still based on the Dronekit Documentation \cite{dronekitdocs}.
	
	First the Dronekit library needs to be installed in the \gls{venv} with \lstinline|pip install dronekit|. To create a file in the \gls{venv} over the terminal \lstinline|nano dronekittest.py| is used. It is noteworthy not to use the same name as the library itself, because python will confuse it. In the created document one then can connect the Raspberry Pi to the \gls{Fc} as can be seen in \cref{lst:listing-connection}.
	\begin{lstlisting}[language=Python, style=myPython, caption=Python DroneKit Example, label=lst:listing-connection]
		from dronekit import connect

		vehicle = connect('/dev/serial0', baud=912600, wait_ready=True)
	\end{lstlisting}
	
	However this will cause an attribute error, as one can see in \cref{lst:attributeerror} 
	\begin{lstlisting}[label=lst:attributeerror, caption={AttributeError after connecting}]
		dronekit/__init__.py" , line 2689, in <module>
		class Parameters(collections.MutableMapping, HasObservers):
		^^^^^^^^^^^^^^^^^^^^^^^^^^
		AttributeError: module 'collections' has no attribute 'MutableMapping'
\end{lstlisting}
	The source of the error is that in python 3.10 the abstract base class, MutapleMapping, was moved from collections to collections.abc. This needs to be changed (\cref{changed line}) in the dronekit source code. Which can be accessed with the the command \cref{sourcecode}\footnote{If it would not be open source, the change(\cref{changed line}) would not be possible}.
	
	\begin{lstlisting}[caption= accessing source code, label=sourcecode]
nano /home/EduPi/mavproxy-env/lib/python3.11/site-packages/dronekit/__init__.py
\end{lstlisting}

	\begin{lstlisting}[caption={changed line in source code (change marked in green)}, label=changed line, language=python, style=myPython, literate={.abc}{{\color{Green}.abc}}4]
		class Parameters(collections.abc.MutableMapping, HasObservers):
	\end{lstlisting}
	
	After this the program worked flawlessly and it was able to give information from the \gls{Fc} over the terminal. As shown with the example \cref{lst:listing-autopilot}, which 
	
	\begin{lstlisting}[language=python, caption={information retrieval}, label=lst:listing-autopilot, style=myPython]
		print( "Autopilot version: %s" %vehicle.version)
	\end{lstlisting}
	\begin{lstlisting}[caption= output from \cref{lst:listing-autopilot}]
		Autopilot version: APM:Copter-4.5.7
	\end{lstlisting}

	The main problem of the outdated Dronekit python library is, that the function \mbox{\lstinline|vehicle.channels|,} which should read the channel values from the radio controller, is returning none instead of values between 900 and 2100. This is a long-known issue and to circumvent it a decorator is used \cite{rcchannelissue}. 

	\begin{Explanation}[Decorator]
		\item A decorator is a function that modifies the behavior of a function or a class \cite{decorator}.
	\end{Explanation} 
	
	\begin{lstlisting}[language=python, style=myPython, label=lst:decorator, caption={decorator for channel values}]
		@vehicle.on_message("RC_CHANNELS")
		def rc_channel_listener(vehicle, name, message):
			global latest_rc_channels
			latest_rc_channels = message
		
		def get_rc_channel_value(channel_number):
			global latest_rc_channels
			if latest_rc_channels is None:
				return None
			channel_value = getattr(latest_rc_channels, f"chan{channel_number}_raw", None)
			return channel_value
		
	\end{lstlisting}
	The decorator in \cref{lst:decorator} is already predefined in the Dronekit library. When calling it with \lstinline|@vehicle.on_message("RC_CHANNELS)| (line 1 \cref{lst:decorator}) and saving it to the global variable \lstinline|latest_rc_channels| (line 4 \cref{lst:decorator}) as a dictionary (\cref{lst:message}).
	
	\begin{lstlisting}[label=lst:message, caption={output from decorator in \cref{lst:decorator}\protect\footnote{}}]
		chan{i}_raw : x
	\end{lstlisting}
	\footnotetext{With i being the channel number and x the value the channel receives form the radiocontroler}
	
	The location is straightforward. There is a home location that is set every time the drone is armed. In addition there is also local frame generated with it, which takes over the coordinates for the longitude and the latitude from a normal \gls{GPS} system, but sets the height to 0 at the starting point. The home location could also be newly set via a MAVlink command. To access any given location local or global can be done over \lstinline|vehicle.location.global_frame|\footnote{"vehicle" is the connection to the \gls{Fc} from \cref{lst:listing-connection}}. This will have a list output \lstinline|[longitude, latitude, altitude]|, to access the longitude a \lstinline|.lon| is added after the \lstinline|_frame| from before\footnote{\lstinline|.lat| for the latitude and \lstinline|.alt| for the altitude}.
	
	To be able to troubleshoot what went wrong in a test flight a \lstinline|log()| function is used. This function can be seen in \cref{lst:logfunciton}. On line 2 the correct file to open is defined, which is then opened in append mode in line 3. Line 4 writes the given content into the file and line 5 closes the file again. This function is used to write out different values during testing, for example the \gls{HDOP} and \gls{VDOP} values, the coordinates and the flight mode.

	\begin{lstlisting}[style=myPython, caption={log function}, label=lst:logfunciton]
		def log(content):
			p = pathlib.Path(__file__).with_name('log.txt')
			o = p.open(mode="a")
			o.write("\n"+ str(datetime.now())+"	" +str(content))
			o.close()
	\end{lstlisting}
	
	The desired coordinates for the drone to fly to are taken from a \lstinline|.tex| file in the format \lstinline|X;Y;Z| in meters and need to be converted into degrees. This is done by the code from \cref{lst:coordinatesconversion}.
	
	\begin{lstlisting}[style=myPython, caption= coordinate conversion, label=lst:coordinatesconversion]
		earth_radius = 6378137.0
		
		changeX = home_location.lat + math.degrees(float(X[i]) / earth_radius)
		changeY = home_location.lon + math.degrees(float(Y[i]) / (earth_radius * math.cos(math.radians(home_location.lat))))
		changeZ = home_location.alt + float(Z[i])
		
	\end{lstlisting}
	
	To fly to a certain coordinate the \lstinline|vehicle.simple_takeoff| and the \lstinline|vehicle.simple_goto| functions are used. However, with the standard parameters from ArduPilot this will not work, because the parameters bitmask of  \lstinline|Brd_Safetyoption| is set to be active even when \lstinline|Brd_safety_deflt| is deactivated. 
	This will not let anything, except the channels defined in \lstinline|Brd_Safety_Mask|, go through to the \gls{ESC}. Hence both, \lstinline|Brd_Safetyoption| and \lstinline|Brd_Safety_Deflt|, need to be deactivated by the code, as demonstrated in \cref{lst:deactivation}
	\begin{lstlisting}[caption={deactivation of parameters}\protect\footnote{}, style=myPython, label=lst:deactivation]
		vehicle.parameters["BRD_SAFETYOPTION"] = 0
	\end{lstlisting}\footnotetext{This can be done with any parameter, by putting it into the place of \lstinline|Brd_Safetyoption|.}
	
	Something that needs to be looked out for when flying low over the ground is if there is a low \gls{VDOP}, because it is not one of the prearm messages that would not hinder the drone from taking off. 
	
	\begin{Explanation}[horizontal and vertical dillution of precision (HDOP/VDOP)]
		\item The \gls{HDOP} or \gls{VDOP} refers to the dillution of the precision of the \gls{GPS}. The values are not in meters and range from under 1 (ideal) up to over 20 (poor). 
	\end{Explanation}
	
	After the most important functions have been defined. They can be put together in an overall flow, as showed in \cref{fig:pythonflow}. It is two nested loops, with the inner loop checking, if the target location is achieved and the outer loop looking if the achieved target location was the last in the list taken form the coordinates.txt file.
		\pagebreak
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\linewidth]{pictures/pythonflow}
	\caption{overall flow}
	\label{fig:pythonflow}
\end{figure}
	% TODO is this ok?

	\section{Results}

	The various test flights showed promising results. The drone followed the path from the coordinates.txt file, which was the main goal of this Matura paper. The test flights have also shown the very sensitive reaction of the drone to the parameter settings. 
	
	The integration of the different software components was also a challenge, due to the fact that the \glsentrylong{OSS} are not transparently documented and some are also outdated. The software components often conflicted during drone takeoff, with one allowing flight while another prevented it\footnote{The prevention always had the upper hand.}. This also shows the difficulty of software integration, which is a tedious and time expensive task.

	This Matura paper also shows how important a log file is for an autonomous system, because once the system takes  control, it is impossible to know what is happening and without the data provided by a log file it is difficult to improve the system.
	
	\section{Discussion and Outlook}
	 It should be noted that the built drone is only a proof of concept and requires further testing and tuning to reach full maturity. Additionally, a (infrared) camera can be added to the Raspberry Pi. Unlike an Arduino, the Raspberry Pi is a fully functioning computer with the potential to add different functionalities, such as sensor data and image processing. The pictures taken by the camera from the Raspberry Pi could be processed directly onboard for tasks such as image recognition. This would be straightforward development on the basis of the Raspberry Pi proven technology.
	
	
	\section{Conclusion}
	A general problem in the development process was that the development location at home lacked both a \gls{GPS} connection and space to test the drone. The trips to another location for testing were time-consuming because every time the drone needed to be tested the entire setup  --including the laptop-- was packed into a bag, moved to the location, and reassembled. Additionally, the weather interfered my testing plans sometimes.
	
	On the other side the infrastructure at home was very efficient, due to the distinction in three blocks, the soldering and electronic workstation, a separate desk for software development, and an always available 3D printer, which came in handy when I misplaced the screw holes in the first iteration of the LowerPiMount and needed to print the revised part again.
	
	The entire project was interesting, and I learned a lot --from sourcing parts to soldering to coding-- but it was also exhausting and sometimes even nerve-racking. Success was not guaranteed, due to the many challenges and technical hurdles faced. So it was quite relieving when the drone finally flew.
	

	
	\newpage
	\renewcommand{\thesubsection}{\Alph{subsection}}
	\counterwithin{figure}{subsection}
	\counterwithin{table}{subsection}
	\pagebreak
	\appendix
	\section{Appendices}
	\subsection{Thanks}
	I first want to thank Cyril Wendel my supervisor who helped me a lot and for his valuable coaching. I also want to thank my Father, my Mother, Claude Meier and Janik Bolli for reviewing the paper.
	\printbibliography
	
	\newpage
	\listoffigures
	% TODO might sort them by author...

	\newpage
	\printglossary[type=\acronymtype]
	\newpage
	\subsection{List of Parts}
	\subsubsection{Physical Parts}
	\begin{itemize}
		\item \gls{Fc}:		Kakute H7 v1.3 (MPU6000) \cite{KakuteH7}
		\item \gls{ESC}: 	Tekko32 F4 Metal 4in1 65A ESC (AM32) \cite{Tekko32}
		\item \gls{GPS}: 	Micro M10 GPS \cite{m10gps}
		\item 4 Motors: 	XING-E Pro 2207 2450KV \cite{xingepro}
		\item Propellers: 	Foxeer Donut 5145 Props \cite{toroidal} or HQProp 5X4.3X3V1S \cite{hqprops}
		\item Battery: 		Tattu 2000mAh 4S 120C 14.8V R-Line Version 3.0 \cite{tattu}
		\item Receiver: 	RP4TD ExpressLRS 2.4GHz True Diversity Receiver \cite{radiomasterreceiver}
		\item Radio: 		Boxer Radio Controller (M2) \cite{radiomasterboxer}
		\item Raspberry Pi:	Raspberry Pi 4 Model B - 2GB \cite{raspberrypi}
		\item Frame:		TBS Source One V5.1 5inch \cite{frame}
		\item Additional Screws: 4x M3x20, 4x M3x30 (for the \gls{Fc}/\gls{ESC} stack), 4x M3x40
		\item Raspberry Pi Mount: 	\url{https://github.com/pythonnoob9903/MA-project/tree/main/Raspberry Pi%20Mount}
	\end{itemize}
	\subsubsection{Non-Physical Parts}
	\begin{itemize}

		\item Code and Coordinates\footnote{Found as dronekittest.py, coordinates.py, and coordinates.txt}:  \url{https://github.com/pythonnoob9903/MA-project/tree/main}
	\end{itemize}
	
\end{document}
